# 日志

**小步快跑，好过不跑**

**不怕出错，就怕不做**

**先敲再优化**



日期/当日提交次数_版本号



一组：**项目可发布版本🚀**的情况。

二组：**完成完整功能✅**的情况。

三组：**维修🛠️**，**优化⚡**，**新增🆕**，**弃用🗑️**的情况。

四组：**测试🧪**，**特性✨**，**暂缓⏸️**的情况。



ps：满足同位多个，有几个就涨几位

​	满足异位均有，各自涨各自有的

# 2025-10-10/001_V0.0.0.1

- 验证“DLC”（热插拔）模式初步可行。
- 确定核心包-补充包-开发工具包（提取核心包的util打包）结构。
- 实现核心包运行时动态加载-卸载补充包静态资源的示例。

# 2025-10-10/002_V0.0.0.2

- 升级插件扫描器，允许定义并筛选指定类型格式的文件进行注册。
  - 插件扫描器现在不限制文件名，只要格式允许，起啥名字都行。

# 2025-10-10/003_V0.0.0.3

- 升级插件扫描器和资源复制器，改为从配置文件定义允许的资源格式白名单。
  - 资源的注册与复制进插件资源映射目录这两个行为均依照白名单执行。

# 2025-10-12/001_V0.0.1.4

- 优化：取消核心包-补充包-开发工具包结构，改用核心包-内置补充包结构。
  - 开发补充包时就在核心包内的插件目录内开发，避免没依赖或找不到类啥的。
  - 开发完成后单独把每个补充包剪切出去，用户按需重新放回来就行。
- 维修：解决了无法在核心包启动前提前加入补充包后无法启动的问题。
- 补充：解决了补充包的Bean不能被核心包容器一并管理的问题。
- 特性：不打算解决卸载补充包时残留的幽灵Bean的问题。
- 暂缓：放弃搞懂前端的JS部分，目前暂定就完全让AI代劳：）。

# 2025-10-15/001_V0.6.14.7

- ✅完成：热插拔机制。
- ✅完成：双监听机制。
- ✅完成：插件资源映射功能。
- ✅完成：插件源码热编译功能。
- ✅完成：插件Bean动态加入功能。
- ✅完成：插件资源注册表管理体系。
- ⚡优化：日志版本号定义与编写规则。
- ⚡优化：程序架构。
  - 插件改为在核心包内开发，完成后移出核心包。
  - 插件接入点分为源码挂载点（根目录下的docking/plugins）与资源挂载点（资源目录下的static/plugins）。

- ⚡优化：所有文件的注释描述。
- ⚡优化：唯一配置文件。
  - 改用相对路径。
  - 两份路径配置，对应IDE环境运行与编译后（target）环境。
- ⚡优化：插件注册表管理器。
  - 删除了复制插件资源与运行资源映射目录相关操作。
  - 修改了插件对象的结构，包含更多插件信息。
- ⚡优化：插件服务器。
  - 删除资源扫描器中将插件资源复制至插件资源映射目录的步骤。
  - 删除资源复制器。
  - 删除资源映射目录删除方法。
- 🆕新增：插件资源配置器。
  - 用于处理插件资源的路径映射。
- 🆕新增：插件控制器。
  - 用于给页面返回最新的插件资源信息对象集合。
- 🆕新增：插件（资源）监听器。
  - 用于监听插件资源放置目录，引发装载与卸载行为。
  - 根据监听事件引发插件服务器的扫描行为。
- 🆕新增：插件（源码）监听器。
  - 用于监听插件源码放置目录，引发装载与卸载行为。
  - 根据监听事件引发热编译行为。
  - 可在运行时注册Bean（会试图把所有的java做成Bean）。
- 🆕新增：插件编译器。
  - 用于在运行时将新加入的插件源码编译掉。
  - 会将每个插件编译后的class文件单独放进这个插件所在的同级目录内。
- 🆕新增：IO，序列化与字符串工具类。
  - 封装了文件IO，序列及反序列化与字符串相关的方法。
- 🗑️弃用：插件监听器。
- 🧪测试：项目打包与不定路径运行测试。
  - 以展开目录形式打包（不做jar，要不然热插拔做不了了）。
  - 成功在非IDE环境启动项目。
  - 成功在项目整体随意移动到任何地方时均能启动项目。
- ✨特性：幽灵豆子问题。
  - 当某个插件卸载时，由这个插件注册的Bean是不会被从容器中删除的（因为似乎留着没啥影响所以得处理）。
- ✨特性：豆子唯一性争夺问题。
  - 当某个插件二次挂载时，第二次注册的Bean会与首次注册的Bean起冲突（幽灵豆子的遗留问题）。
  - 暂定尝试赋予插件独立的子容器解决。

# 2025-10-16/001_V0.6.23.8

- 🛠️维修：幽灵豆子问题。
- 🛠️维修：豆子唯一性争夺问题。
- ⚡优化：日志排版。
- ⚡优化：项目目录结构。
- ⚡优化：插件（源码）监听器。
  - 删除了旧的动态豆子注册器相关引用。
  - 使用子容器管理器接替动态注册Bean的功能。
  - 添加监听插件的删除事件，删除时卸载对应的子容器。
- 🆕新增：功能文档。
- 🆕新增：目录结构文档。
- 🆕新增：子容器管理器。
  - 用于管理插件子容器的生命周期（创建和销毁）。
- 🗑️弃用：动态豆子注册器。
- ✨特性：生产环境插件Bean注册失败问题。
  - 在打包后的环境所有文件均为.class，但插件编译器只认.java经过转换后才能注册。
  - 暂定原逻辑保留，加入当没有.java则尝试寻找.class，找到的话跳过编译，直接可以注册豆子。

# 2025-10-17/001_V0.6.28.8

- 🛠️维修：生产环境插件Bean注册失败问题。
- ⚡优化：序列化与字符串工具类。
  - 修改了类名，剔除了IO操作的职能。
  - 修改了一些注释。
  - 泛化了原来的方法，使其可以适应更多情况。
- ⚡优化：插件编译器。
  - 重构了这个类，提取并封装了一些方法。
  - 加入了只有.class却没有.java情况的分支处理逻辑。
- 🆕新增：项目应用的开源协议（MIT）。
  - 项目所有源码文件均同时在头添加了版权声明。
- 🆕新增：文件IO工具类。
  - 封装了文件操作与IO操作相关的方法。

# 2025-10-19/001_V0.7.33.10

- ✅完成：插件资源动态修改功能。
  - 运行时允许修改插件的资源文件，并实时响应修改。
- 🛠️维修：无法在运行时修改插件资源文件。
- ⚡优化：项目依赖。
  - 添加了commons-io（专门处理 Java IO的工具库）和commons-codec（编码/解码工具库）的依赖。

- ⚡优化：插件（资源）监听器。
  - 改用commons-io代替Java NIO，支持递归监听和更精准的事件捕获，写法也更简洁易懂。
  - 添加修改事件监听。
  - 将文件版本哈希并入响应，欺骗浏览器进行资源刷新（使用不同的url浏览器就会当成新玩意重新加载，绕过该死的浏览器缓存，这样才能实时响应资源的修改）。
- ⚡优化：插件服务器。
  - 添加获取文件哈希的逻辑，并将其并入响应。

- ⚡优化：index.js
  - 添加识别文件哈希的逻辑。
  - 仅刷新文件哈希出现变化的资源，避免了全量刷新搞得页面一闪一闪的。

- 🧪测试：插件资源是否可以在挂载状态热修改。
  - 无法实时响应修改。

- ✨特性：无法在运行时修改插件资源文件。

# 2025-10-22/001_V0.7.40.12

- 🛠️维修：添加或删除某个插件资源无法刷新。
  - 在前端JS添加了一个同步插件注册表，用于保存最新一次请求响应回来的插件注册表。
  - 与下一次响应的做对比来判断是否出现插件整体挂载或卸载。
- ⚡优化：放项目的目录。
  - 把没用的和无关的东西清理走了。
  - 项目目录只放项目相关。
- ⚡优化：项目目录结构。
  - 使用新的结构，使项目的可读性，分离性和扩展性更好（应该）。
- ⚡优化：目录结构文档。
  - 更新对应了最新的项目结构。
- ⚡优化：功能文档。
  - 更新一下已完成的功能。
  - 这个项目是个人需求导向，我想加啥就写啥，没啥好计划的功能。
  - 所以以实际开发进度与更新日志为准，功能文档仅作参考。
- ⚡优化：插件（资源）监听器。
  - 优化语义。
  - 从PluginResourceListening改成PluginResourceListener。
- ⚡优化：插件（源码）监听器。
  - 优化语义。
  - 从PluginSourceListening改成PluginSourceListener。

- 🧪测试：中间件不依赖容器直接集成至项目。
  - 不中。
  - 傻逼玩意Rabbit不支持，ES要求太多，Redis也懒得用了。
  - 决定中间件就不要来掺和我项目了。

- ✨特性：添加或删除某个插件资源无法刷新。
  - 添加或删除某个插件资源目录时页面不能响应挂载渲染和卸载清除两个事件。
  - 似乎因为上版本加的让JS刷新认版本号，而整体的挂载与删除对于里面的资源本身是没有变化的。
  - 版本号又是根据文件哈希决定。
  - 所以挂载或卸载时插件资源的版本号实际没变。
  - 所以坏掉了。

# 2025-10-23/001_V0.12.53.13

- ✅完成：指定目录扫描功能。
  - 扫描指定目录与其下x级，指定扫描类型（根据配置文件决定）的其它目录与文件。
  - 结果封装为节点并包装成节点树，方便定义，扩展与管理。
- ✅完成：JS解析节点树功能。
  - 前端将会解析返回的节点树。
  - 解析并使用DOM操作创建元素拼出结构并渲染。
- ✅完成：JS拼接节点树功能。
  - 若两次扫描实际属于同一线性关系（如a/b/c），但一次扫了a/，一次扫了a/b/c。
  - 中间接续关系的a/b页面不知道其存在，则默认会将这两次扫描暂时视作同级目录。
  - 当扫描了a/b，页面得到中间目录后，将会重新构建节点树。
  - 将节点树重建为实际从属关系，并刷新页面渲染的结构。
- ✅完成：启动时获取设备根盘功能。
  - 在启动程序或刷新页面（JS被重新触发页面加载事件）时，向后端发送初始化请求。
  - 返回当前设备的所有根路径（如windows将会返回所有盘符）。
  - 不要让页面空空的，用户不知道要干嘛（要把用户当没脑子的傻逼照顾）。
- ✅完成：点击进入下一级功能。
  - 当点击页面中的目录节点时，将会向后端请求这个节点的下一级成员。
  - 前端将返回的节点树拼接上去。
- ⚡优化：配置文件。
  - 增加定义扫描深度（向下深入几层）与扫描类型（是否包含隐藏文件/目录或系统文件/目录）。
- ⚡优化：核心包主页与样式。
  - 加入扫描相关测试标签。
- ⚡优化：核心包脚本。
  - 解析节点树和拼接节点树这俩功能都加在这里了。
- ⚡优化：文件IO工具类。
  - 新增了目录获取，文件后缀操作，ID生成等四个新方法。
- 🆕新增：跨域配置器。
  - 配置跨域映射，让页面可以顺利访问程序的URL访问点。
- 🆕新增：文件控制器。
  - 用于获取文件相关信息的请求点。
- 🆕新增：指定目录扫描器。
  - 用于扫描提供的指定目录，包括其中的任何文件或其它子目录。 
  - 并将其全部封装为节点，且将进一步构建为节点树。 
  - 扫描深度和扫描类型均由配置文件决定。
- 🆕新增：节点对象。
  - 代表树中的任意一个节点。
  - 因为文件扫描与索引采用树状结构，文件与目录均抽象表示为节点。
- 🆕新增：文件节点对象。
  - 继承节点对象，补充文件节点的独有字段。
- 🆕新增：目录节点对象。
  - 继承节点对象，补充目录节点的独有字段。
- 🆕新增：节点树对象。
  - 代表所有节点的集合状态，管理所有节点。
- 🆕新增：节点类型枚举。
  - 定义节点为文件还是目录。
- 🆕新增：扫描状态枚举。
  - 定义节点的扫描状态，同时方便路径接续。
- ⏸️暂缓：核心包JS理解问题。
  - 老问题。
  - 前端不熟，全是AI代工。
  - 找时间搞懂JS里面到底装了啥写了啥。

# 2025-10-24/001_V0.12.60.13

- ⚡优化：文件控制器。
  - 使用标准视图响应对象包装响应。
- ⚡优化：插件控制器。
  - 使用标准视图响应对象包装响应。
- ⚡优化：核心包JS。
  - 适应新的响应结构。
- ⚡优化：日志文档。
  - 改进了部分描述与阅读性。
- ⚡优化：目录结构文档。
  - 补充了新的修改。
- 🆕新增：标准视图响应对象。
  - 用于统一所有URL接口的响应格式。
- 🆕新增：基本控制器。
  - 用于定义所有控制器的响应模板，使用标准视图响应对象封装响应。

# 2025-10-28/001_V0.12.69.13

- ⚡优化：maven依赖。
  - 添加了spring-boot-starter-aop（切面依赖）。
- ⚡优化：配置文件。
  - 增加了异常日志写入配置。
  - 包含日志写入地址，与调用链打印深度。
- ⚡优化：文件IO工具类。
  - 把所有方法上面加的static标记删掉了。
  - 把这个工具类也标记为豆子了。
  - 新增了用于写入异常日志的相关方法。
- ⚡优化：序列化与字符串工具类。
  - 把所有方法上面加的static标记删掉了。
  - 把这个工具类也标记为豆子了。
- ⚡优化：插件服务器。
  - 因为序列化与字符串工具类取消了static状态，所以这里需要引入它的Bean。
- ⚡优化：插件编译器。
  - 因为文件IO工具类取消了static状态，所以这里需要引入它的Bean。
- ⚡优化：文件控制器。
  - 因为文件IO工具类取消了static状态，所以这里需要引入它的Bean。
- ⚡优化：指定目录扫描器。
  - 因为文件IO工具类取消了static状态，所以这里需要引入它的Bean。
- 🆕新增：自定义异常切面。
  - 用于发现全局的任意异常时，侵入并进行日志写入。

# 2025-10-29/001_V0.13.79.18

- ✅完成：冷遗忘功能。
  - 一定时间未被用户操作的节点将会自动遗忘。
  - 就是定时对节点树中的节点进行热度衰减，并同时进行冷节点裁剪。 
  - 根据我自己写的非常之牛逼的算法（嵌套双向递归裁剪）实现的：）
  - 就是衰减-上追-下探-清理这么个流程。
  - 避免节点树过于庞大搞得哪里受不了。
  - 冷节点就是节点对象的点击热度字段归零的状态（用户一直不点就会变冷）。
- ⚡优化：配置文件。
  - 新增了节点热度衰减配置，包含衰减速度（ms），衰减量（每刻度衰减的热度），起始阈值（节点树中的节点数量超过这个值才会开始衰减）三个玩意。
- ⚡优化：节点对象。
  - 新增点击热度字段。
- ⚡优化：节点树对象。
  - 将节点树改成单例模式，全局唯一的。
  - 还整成了Bean。
  - 并添加了各种操作与管理树的方法。
- ⚡优化：指定目录扫描器。
  - 把使用节点树对象里的静态方法的地方改成使用Bean注入的节点树对象内提供的方法。
- ⚡优化：文件控制器。
  - 新增了用于热度增长（不过还没实现）和获取节点树的两个接口方法。
- ⚡优化：核心包JS。
  - 添加与获取资源的轮询速率同步的，获取最新节点树的轮询，用于刷新节点。
  - 额外渲染了节点的热度值。
- ⚡优化：核心包CSS。
  - 刷新节点的热度值时，节点名字会闪一下：）
- ⚡优化：SB启动器。
  - 启用了计划，没见过的玩意，反正要启用这玩意才能做定时任务。
- 🆕新增：节点冷遗忘。
  - 定时对树中的节点进行热度衰减，并同时进行冷节点裁剪。 避免节点树过于庞大搞得哪里受不了。
  - 就是个计时器和冷遗忘的核心算法。
- 🆕新增：文件系统服务器。
  - 用于核心包的，对文件系统进行操作或构建的一些功能。
- ✨特性：前端树拼接异常。
  - 目前仅在指定扫描一个深层子目录后，再扫描它的上级目录，然后逐层点击到这个子目录后出现。
  - 这个子目录出现了两次，首次扫描的与根目录同级的一次，它原位置的一次。
  - 还不确定问题在哪里。
- ✨特性：节点热度衰减状态回显迟滞。
  - 热度可以在每次刷新时都实时回显当然最好。
  - 现在就是因为衰减在后端进行，前端目前获取最新的节点树的方式似乎只有指定扫描和点击下一级两个方法。
  - 所以若用户一直不点节点，节点的热度的衰减状态是看不到的，页面也就无法刷新的。
  - 给前端加一个与获取资源同步的获取节点树的轮询请求应该可以解决问题。
- ✨特性：点击节点似乎没有增加热度。
  - 检查一下逻辑就好啦，顶多就再加个请求啦。
- ✨特性：根节点热度归零后无法点击。
  - 好像只有在冷遗忘功能直接删到根节点时才会出现。
  - 也不太确定问题在哪里。
- ✨特性：存在子目录但没有展开的节点热度归零时不会被删除。
  - 检查一下目录节点的扫描状态字段理应就解决了。

# 2025-10-30/001_V0.13.79.18

开始罢工。

孩子没信心了。

# 2025-11-06/001_V0.14.88.21

- ✅完成：节点加热。
  - 节点被点击后给它加热。
  - 用户常用的节点不要被冷遗忘机制杀掉。
- 🛠️维修：节点热度衰减状态回显迟滞。
  - V0.13.79.18已经修好了，忘记记录了。
  - 核心包JS多加了一个轮询，速度与资源请求速率同步，专门用来获取最新的节点树状态。
- 🛠️维修：点击节点似乎没有增加热度。
  - V0.13.79.18都加了这个接口了，前端忘接了：）
  - 节点被点击时请求这个接口就好了。
- 🛠️维修：根节点热度归零后无法点击。
  - 就是扫描状态判断深度不足问题导致的。
  - 扫描状态判断深度不足修好了这个也就好了。
  - 还在前端JS额外加了一段，若某个节点为完全扫描状态且热度归零，还是可以再次申请扫描这个目录。
  - 就是处理如根节点的所有子级都被展开，且都冷却遗忘了，这个根节点就是完全扫描状态但没有子节点集的问题。
- 🛠️维修：存在子目录但没有展开的节点热度归零时不会被删除。
  - 这次检查又没事了？？？
  - 那就当修好了吧：）
  - 不能复现就不算问题。
- 🛠️维修：扫描状态判断深度不足。
  - 在指定目录扫描器里面的深度扫描器里多塞了两段逻辑。
  - 用于判断一下当前节点是否存在子级，用于给父节点标记扫描状态。
  - 一个适应孙子节点存在的情况（存在且做成节点进入树了），另一个适应孙子节点不存在的情况（存在但还没进入树）。
- 🛠️维修：丧子节点无法展开。
  - 改了一下核心包JS。
  - 若节点热度没有清零，且存在子节点，则仅做展开收起，不请求扫描。
  - 若热度清零，或没有子节点，那就请求扫描。
  - 子节点直接检查DOM元素看看有没有渲染来判断。
- ⚡优化：日志文件。
  - 在末尾添加了备注小节。
  - 用于记录一些东西（比如某个特性几个版本都修不好，怕久了忘了这个特性了）。
- ⚡优化：核心包JS。
  - 主要就是修了一堆问题，让AI搓了很多新玩意。
  - 整个项目中也就JS我完全让AI写的了，自己干脆就没看没理过。
- ⚡优化：指定目录扫描器。
  - 主要就是给深度扫描器加了两段逻辑，都是检查扫描目标节点是否存在子级的。
  - 用于解决目录节点只扫描了直接级节点组，误认为扫描完全，将扫描状态标记为完全扫描，但忽略了孙子级节点组的存在。
  - 一个前置的，专用于没有进入树（还不是节点）的成员。
  - 一个后置的，专用于已经进入树（已被树管理）的成员。
- ✨特性：页面刷新破坏节点树。
  - 在打开根目录外的其它任意目录时，若刷新页面，所有打开过的目录会被提升至根级别。
  - 原来的父节点下没有这个节点了。
  - 且这个节点也无法下探了。
  - 不知道怎么个事。
- ✨特性：扫描状态判断深度不足。
  - 若某个目录节点的直接子级被完全扫描。
  - 那么不管这个目录节点的子级是否存在更深的孙子级，这个目录节点都会被标记为完全扫描。
  - 这也就是导致根节点热度归零后无法点击问题的问题。
- ✨特性：丧子节点无法展开。
  - 若某个节点的所有子节点展开后由于冷却被删除，且这个节点本身热度还没归零。
  - 再次试图点击这个节点以重新扫描查看这些被删除的子节点时，不知道怎么的无法发送扫描请求。
  - 似乎是核心包JS中，使用在前端副本节点树中直接检查节点的子节点集的长度没用。
  - 副本节点树没用，那干脆扫DOM？？？

# 2025-11-12/001_V0.15.96.27

- ✅完成：目录监听功能。
  - 监听文件系统，反应文件或目录的增删改事件。
  - 与节点树同步，仅对被管理的节点进行监听。
  - 且尽可能合并节点组成路径段，减少监听线程的创建。

- ⚡优化：监听树对象。
  - 把构建路径段的指导思想从扩散组合改成分支切割。
  - 扩散组合：由给定扩散源（任意节点）起，以三向（上级，同级，下级）进行扩散探索，将结果尽可能组合，减少路径段数量。
  - 分支切割：由根起向下遍历，遇到分叉即截断，上面的作为一个路径段，保证所有路径段的单链形式。
  - 主要是扩散组合在广度问题（兄弟节点的无限不可控）和广度深度交叉（兄弟还有孩子呢）这两点上面简直是噩梦。
- ⚡优化：指定目录扫描器。
  - 在首次进行扫描的地方，当节点树初始化后，进行监听树的建立。
  - 就是初始化监听树，初始化路径段，再启动一下监听单元组。

- ⚡优化：节点冷遗忘。
  - 在清理方法内，确定发生了由冷遗忘引发的节点树变动时，重建路径段与监听单元组。

- ⚡优化：配置文件。
  - 新增了文件系统监听配置的防抖间隔字段。
  - 定义最少需要间隔多久才能触发一次监听组重建行为。

- 🆕新增：监听树对象。
  - 代表所有路径段的集合状态，管理所有路径段。 
  - 树为单例树，让容器代管。
  -  路径段代表某段路径（内包含任意数量或层级的其它文件或目录）。 
  - 路径段中的成员是由有序，且必须存在直系关系的路径组成。 
  - 路径段用于方便监听行为。
  -  直接监听整个文件系统太吓人了，完全跟随节点分别创建监听也受不了。
  -  所以引入监听树，管理监听段，尽可能组合相连的节点做监听，避免扫盘，也避免线程多的要死。
  - 包括对节点树的分支切割逻辑（获取路径段用的）也赛到这里了。

- 🆕新增：监听单元对象。
  - 定义了监听器结构与事件行为。 
  - 每个路径段理应都会被分配一个单独的监听单元进行事件监听。

- 🆕新增：监听单元组对象。
  - 用于管理所有被创建的监听单元。
  - 暂时只有添加和删除监听单元两个方法。
  - 就是个盒子。

- 🆕新增：文件系统监听器。
  - 监听整个文件系统，反应文件或目录的增删改事件。
  - 这里就是整个监听体系的入口，由这里调用构建或重建监听树与监听单元组。

- 🧪测试：设备保有线程极限。
  - 验证一下设备能撑住多个甚至大量线程，项目里要异步的地方挺多。
  - 等了快二十分钟都没死，上万是绝对没问题的。
- 🧪测试：打包测试。
  - 更新这么多，好久没试试还能不能打包且正常运行了。
  - 结果还能动！
  - 这么多更新竟然没给它搞坏。

- ✨特性：新增节点未加入监听。
  - 在节点树加入新节点时，忘记补上重建路径段和监听单元组的逻辑了。
  - 搞得新加入的节点中发生的事件不会被监听。
  - 补个逻辑就好，理应不难。

- ⏸️暂缓：控制台输出方式。
  - 找时间整理一下项目中的所有控制台输出。
  - 现在乱七八糟的乱喷。

- ⏸️暂缓：无用代码清理。
  - 清理一下所有类，把没用的引用或方法啥的都删掉。

- ⏸️暂缓：配置文件整理。
  - 整理配置文件中的所有自定义配置字段，梳理层级与命名。
  - 也是有点乱了。


# 2025-11-13/001_V0.15.115.28

- ⚡优化：配置文件。
  - 重新调整组织了自定义配置字段的结构。
- ⚡优化：跨域配置器。
  - 补充了注释。
  - 规范了控制台输出。
- ⚡优化：插件资源配置器。
  - 规范了控制台输出。
- ⚡优化：监听树对象。
  - 补充了注释。
  - 规范了控制台输出。
- ⚡优化：监听单元对象。
  - 补充了注释。
  - 规范了控制台输出。
- ⚡优化：文件系统服务器。
  - 补充了注释。
- ⚡优化：插件注册表管理器。
  - 规范了控制台输出。
- ⚡优化：插件服务器。
  - 补充了注释。
  - 规范了控制台输出。
  - 应用了新的配置字段路径。
- ⚡优化：文件控制器。
  - 补充了注释。
- ⚡优化：插件控制器。
  - 补充了注释。
- ⚡优化：自定义异常切面。
  - 补充了注释。
  - 规范了控制台输出。
- ⚡优化：文件系统监听器。
  - 补充了注释。
  - 规范了控制台输出。
  - 应用了新的配置字段路径。
- ⚡优化：插件（资源）监听器。
  - 补充了注释。
  - 规范了控制台输出。
  - 应用了新的配置字段路径。
- ⚡优化：插件（源码）监听器。
  - 补充了注释。
  - 规范了控制台输出。
  - 应用了新的配置字段路径。
- ⚡优化：指定目录扫描器。
  - 补充了注释。
  - 规范了控制台输出。
  - 应用了新的配置字段路径。
- ⚡优化：节点冷遗忘。
  - 补充了注释。
  - 加了个首次延时字段。
  - 为避免首次启动程序时，这玩意赶在节点树构建前就开始衰减。
  - 所以让定时任务等一下子。
  - 应用了新的配置字段路径。
- ⚡优化：插件编译器。
  - 补充了注释。
  - 规范了控制台输出。
- ⚡优化：子容器管理器。
  - 补充了注释。
  - 规范了控制台输出。
- ⚡优化：文件IO工具类。
  - 应用了新的配置字段路径。
- ✨特性：页面目录折叠异常。
  - 当页面打的获取最新节点树的请求返回时，所有目录会被强制展开。
  - 折不折叠不能被请求控制啊。
  - 反正又是核心包JS的事了。

# 2025-11-13/002_V0.15.117.28

- 🛠️维修：新增节点未加入监听。
  - 改了一下指定目录扫描器中的重建点就修好了。
  - 就一行代码，换个位置的事。
- ⚡优化：指定目录扫描器。
  - 移动了重建路径段与监听单元组的调用点。
  - 从首次加载点丢到的初始扫描器里面。
  - 就是说本来只有在页面首次加载时才会重建，现在只要是出发了扫描器（扫描器被触发的话一般节点树就会发生变化）就会重建。

# 2025-11-16/001_V0.15.130.30

- 🛠️维修：没有建立关系的深层节点无法被监听。
  - 在节点树对象里面加了个获取所有根节点的方法。
  - 然后把监听树对象里面的根遍历方法中的获取根节点的调用改一下就好。
  - 就是找错地方了。
- 🛠️维修：前端树拼接异常。
  - 把核心包JS分离后莫名奇妙的自己好了？？？
  - 也是不知道为什么坏了，现在又是不知道为什么好了。
- ⚡优化：核心包主页。
  - 就把JS引用改了一下，一行罢了。

- ⚡优化：监听树对象。
  - 把获取设备根的地方改成获取节点树的根节点。

- ⚡优化：插件服务器。
  - 补充了非常详细的插件注册表打印方法。
  - 控制台里可以清楚看到都注册了些啥玩意进来。
- ⚡优化：节点树对象。
  - 加了个获取根节点集合的方法。
- 🆕新增：核心包JS（main.js）。
  - 用于其它功能的调用，与页面加载，刷新与轮询等事件的控制。

- 🆕新增：核心包JS（api.js）。
  - 构建了标准请求体，对应后端提供的核心包页面专用接口的结构。
  - 前端请求均使用这个结构进行发送。

- 🆕新增：核心包JS（state.js）。
  - 用于定义前端节点树与根节点集两个重要对象。

- 🆕新增：核心包JS（plugin-manager.js）。
  - 用于管理插件加入或离开核心包时的渲染状态或其它相关方法。

- 🆕新增：核心包JS（tree-core.js）。
  - 用于管理前端节点树的核心方法。
  - 包括获取目录，修复树，修复节点父子引用，重建节点和轮询同步。

- 🆕新增：核心包JS（tree-dom.js）。
  - 用于管理前端节点树的渲染方法。
  - 包括树渲染（根渲染，子节点渲染）和热度渲染。

- 🗑️弃用：核心包JS（index.js）。
  - 做了JS分离，全部揉进一个文件太恶心了（JS本身就恶心）。

- 🧪测试：多级插件资源识别。
  - 看看如果插件资源（尤其如css和js）存在多级目录时还能不能全部识别并注册。
  - 目前看来是可以的。
- ✨特性：没有建立关系的深层节点无法被监听。
  - 因为监听树对象里面的根遍历方法中用来取根的方法用错了。
  - 理应从节点树里取根节点，我写成了从设备中取根目录。
  - 搞得如果我指定扫描一个深层目录，因为没有和现有节点的直接关系，所以会被提升到根级别。
  - 但这是节点树的根，不是设备的根。
  - 且根遍历方法逻辑就是从上往下遍历并截取路径段。
  - 所以构建路径段时就不知道还有这玩意的存在。

# 注

- 2025-11-06/001_V0.14.89.21（✨）：页面刷新破坏节点树——尚未修复（修不好）。
- 2025-11-13/001_V0.15.116.28（✨）：页面目录折叠异常——等待排班。
- 无对应版本：未定义：冷遗忘逻辑修改为不用管兄弟与其子级有没有冷，就看自己的子级和父级就行了。

